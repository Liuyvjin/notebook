# gcc编译动态库和静态库

#### 目录

[TOC]

## 一、静态库、动态库和头文件概念

### 1. 库和头文件的关系

先来回顾程序编译的过程:

```mermaid
graph LR
	A((源文件.h,.cpp等))-->B[预编译]
	B-->C[编译]
	C-->D[汇编.o]
	subgraph 
	D-->E[链接]
    F[静态库.a]-->E
    G[动态库.so]-->E
	end
	E-->H((可执行程序))
	
```

我们平时写程序的时候都是站在巨人的肩膀上，会include很多头文件，这些头文件里包含了库函数的声明。在预编译阶段编译器就会把头文件.h的内容写进源文件中，这样编译器就能够**检查源代码对于库函数的调用格式是否正确**。这其实就是头文件唯一的功能，它实际上和库文件并没有什么关联，只是库文件里有头文件中函数的定义，因此库文件的源文件名其实可以和头文件不同，库也可以不包含头文件。（如下例子中addnum.h，addnums.c）

之后就是编译和链接阶段，链接器会将多个指定的.o，.a，.so文件链接成一个可执行程序，编译器会在库里寻找之前使用过，但是还没有定义的函数。如果找不到，就会报错。

总而言之，头文件的作用是向编译器担保，这样使用函数准没错，之后会找到它们的具体定义的，至于在哪里寻找这些函数，头文件也不知道。需要我们在链接时将库加入，这样编译器就能在这些库里找到函数实现。

### 2. 动态库和静态库

**静态库**是编译的时候就会写入可执行文件，成为它物理上的组成部分，之后运行可执行文件无需再使用静态库。优点是程序不受环境的影响，缺点是文件一般较大。

**动态库**是编译的时候不写入可执行文件，只将所需动态库的信息写入，之后运行时，可执行文件再去一些路径查寻并使用指定的动态库。优点是文件小，缺点是受环境影响。

## 二、实例介绍

[参考代码](./gcc_lib实例)

### 1. 实例工程的文件结构

```shell
.
├── build
├── lib
│   ├── libadd.a     # 静态库
│   └── libdeadd.so  # 动态库
├── libsrc
│   ├── addnum.h     # 头文件
│   └── addnums.c    # 实现文件
└── src
    └── main.c       # 主程序
```

- libsrc ：包含了库的头文件和实现文件
- src：包含了主程序源文件
- lib：存放生成的库
- build：用来存放生成的可执行程序

### 2. 指定头文件路径

#### 2.1 参数`-I`

编译时通过 `-I`参数指定头文件目录，中间可以无空格如`-Ipath`

```shell
gcc ../src/main.c  -I../libsrc/
可以指定多个地址
gcc ../src/main.c  -I../libsrc/ -I./lib2
```

因为只含了头文件，没有函数实现，因此会报错

```shell
/tmp/ccaRb8Wu.o：在函数‘main’中：
main.c:(.text+0x28)：对‘add’未定义的引用
collect2: error: ld returned 1 exit status
```

#### 2.2 修改环境变量

设置gcc路径变量，C_INCLUDE_PATH、CPLUS_INCLUDE_PATH 、CPATH

+ C_INCLUDE_PATH编译 **C 程序**时使用该环境变量。该环境变量指定一个或多个**目录名列表，查找头文件**，就好像在命令行中指定 -isystem 选项一样。会首先查找 -isystem 指定的所有目录。
+ CPLUS_INCLUDE_PATH编译 **C++ 程序**时使用该环境变量。该环境变量指定一个或多个目录名列表，查找头文件，就好像在命令行中指定 -isystem 选项一样。会首先查找 -isystem 指定的所有目录。
+ CPATH 编译 C 、 C++ 和 Objective-C 程序时使用该环境变量。该环 境变量指定一个或多个目录名列表，查找头文件，就好像在命令行中指定-l 选项一样。会首先查找-l 指定的所有目录。

```shell
export C_INCLUDE_PATH=$C_INCLUDE_PATH:/hellolib/lib/
```

#### 2.3 主程序中添加路径

有一种方法可以不用在编译时指定头文件目录，就是在main.c文件包含头文件时带上路径：`#include"../libsrc/addnum.h"`，默认情况下这个路径优先级更高，会覆盖掉`-I`指定的目录。

### 3. 使用静态库

#### 3.1 静态库的创建

 先将库文件编译成汇编代码.o，`-c`编译而不链接

```shell
gcc -c ../libsrc/addnums.c
```

执行后形成/build/addnums.o中间文件。

创建静态库，`ar`命令：
```shell
ar -rsv ../lib/lib[库名].a   addnums.o 
例如： ar -rsv ../lib/libadd.a   addnums.o 
```
+ r：在库中插入模块(替换)。当插入的模块名已经在库中存在，则替换同名的模块。
+ s：写入一个目标文件索引到库中，或者更新一个存在的目标文件索引。
+ v：该选项用来显示执行操作选项的附加信息。
+ t：显示库的模块表清单。一般只显示模块名。
+ 链接库的名称为 lib[name].so/.a

此后中间文件.o就没有作用了，可以删除。

可以用`-t`查看libadd.a包含的模块

```
ar -t ../lib/libadd.a 
```

#### 3.2 静态库的链接

编译链接， `-L`链接库路径，`-l`链接库的中间名字，无空格

```shell
gcc -o main ../src/main.c  -L../lib/  -ladd
```

报错，因为没有指定头文件的位置，而编译过程先是预编译(需要头文件)，加上：

```shell
gcc -o main ../src/main.c -I../libsrc -L../lib/ -ladd  
```

尝试运行这个可执行文件，正常。可以用`ldd`命令查看一个命令**运行时**需要的链接库：`ldd main`，发现没有自己的静态库，把main移动到其他目录也可以正常执行，说明编译的时候已经将静态库整体写入，运行时无需再寻找静态库。

### 4. 使用动态库

#### 4.1 动态库的创建

无需生成中间文件.o，直接生成库.so：

```shell
gcc -fpic -shared -o    [生成路径/lib[库名].so]   [源路径/库文件名]
gcc -fpic -shared -o     ../lib/libdeadd.so     ../libsrc/addnums.c
```

- -shared ：指定生成动态链接库。
- -static ：指定生成静态链接库。# 难道可以不用ar用gcc生成静态库吗？
- -fpic：表示编译为位置独立的代码，用于编译共享库。目标文件需要创建成位置无关码，念上就是在可执行程序装载它们的时候，它们可以放在可执行程序的内存里的任何地方。

#### 4.2 编译时动态库的链接

参数与静态库一样：`-L`为库路径，`-l`为库名

```shell
gcc -o main ../src/main.c  -I../srclib   -L../lib   -ldeadd
```

编译成功，但是运行出错。使用lld查看main的执行链接有一项是`libdeadd.so => not found`，说明程序运行时找不到动态库。`-L`只能指定编译时的库路径。

#### 4.3 运行时动态库的链接

运行时，操作系统会去一些默认的地点查找动态库，而编译时`-L`指定的动态库的位置系统是不知道的。这些默认地点为`/lib`，`/usr/lib`，`/etc/ld.so.conf文件所记载的位置`（按优先级排序）。将自己的动态库的路径写进去或将动态库移动到可行目录下面就行了。修改了以后要运行`ldconfig`更新。它的作用就是将`/etc/ld.so.conf`列出的路径下的库文件缓存到`/etc/ld.so.cache`以供使用。

第二种指定动态库搜索路径的方式是修改环境变量LD_LIBRARY_PATH ，添加自己的路径，这种方式指定的地点优先于默认路径。但是只在当前终端有效。

总结路径查找的优先级如下：

* LD_LIBRARY_PATH
* /lib
* /usr/lib
* /etc/ld.so.conf文件所记载的位置

[回到目录](#目录)

## 三、总结与补充

1. 编译和运行对比

|              | 编译                         | 运行                                                         |
| ---------------- | ---------------------------- | :-------------------------------------------------- |
| 查找库类型   | 静态库或动态库               | 动态库                                                       |
| 指定查找路径 | -L；环境变量LIBRARY_PATH     | -Wl；rpath；-R选项；/etc/ld.so.conf文件；环境变量LD_LIBRARY_PATH |
| 默认查找路径 | /lib /usr/lib /usr/local/lib | /lib /usr/lib                                                |
| 链接器       | ld                           | /lib/ld-linux.so.2                                           |

2. 标准库不用指定链接库路径-L和链接库名-l，猜测是根据头文件自动链接了。

3. 链接库的隐式调用，即将动态库看成一个普通的.o文件，不用`-l`参数指定。

   **动态库**：

   ```shell
   gcc -o main ../src/main.c ../lib/libdeadd.so  -I../libsrc/
   ```

   这样做的优点是操作简便，得到的main也可以正常运行，但是只要`libdeadd.so`和`main`的相对位置改变，就不能正常运行。所以只适合在调试的时候用。

   **静态库**：

   链接静态库也可以直接当.o文件而且没有什么缺点。

[回到目录](#目录)